#' Generate an unstructured signal
#' 
#' @param m An integer value, the number of hypotheses
#' @param pi0 A numeric value in \eqn{[0,1]}, the proportion of true null signals
#' @param barmu A numeric value, the strength of the signal 
#' @return A numeric vector of length \code{m}, the signal values for each hypothesis
#' @export
#' @examples
#' m <- 100
#' pi0 <- 0.7
#' barmu <- 4
#' mu <- gen.mu.noleaves(m = m, pi0 = pi0, barmu = barmu) 
#' plot(mu)
gen.mu.noleaves <- function(m, pi0, barmu) {
    mu <- numeric(m)
    m0 <- floor(m * pi0)
    m1 <- m - m0
    mu[sample(seq(1, m), m1)] <- barmu
    mu
}

#' Generate a block of signal of Gaussian shape
#' 
#' @param barmu A numeric value, the strength of the signal 
#' @param len An integer value, teh length of the block
#' @return A numeric vector of length \code{len}, the signal values in the block
#' @export
#' @examples
#' n <- 30 
#' plot(1:n, gauss_bloc(1, n) , type = 'l')
gauss_bloc <- function(barmu, len) {
    # this choice of sigma2 is so that the values at the edge of the vector 'out' are = 1/200
    sigma2 <- len^2/(8 * log(200))
    out <- exp(-(seq_len(len) - floor(len/2))^2/(2 * sigma2))
    return(barmu * out/mean(out))
}

#' Generate the signal in the leaves of the tree
#' 
#' @param m An integer value, the number of hypotheses
#' @param K1 An integer value, the number of non-null leaves
#' @param d A numeric value in \eqn{[0,1]}, the proportion of non-null signals in each non-null leaf
#' @param grouped A boolean value, whether the non-null leaves are contiguous or not
#' @param setting A character value specifying the shape of the signal in each non-null leaf
#' @param barmu A numeric value, the strength of the signal 
#' @param leaf_list A list of leaves as generated by \code{dyadic.from.Nnn} functions
#' @return A numeric vector of length \code{m}, the signal values for each hypothesis
#' @details If \code{setting == "const"} the signal is constant equal to \eqn{barmu}. If \code{setting == "gauss"} the signal has a Gaussian shape. If \code{setting == "poisson"} the signal has a Poisson shape. 
#' @export
#' @importFrom stats rpois rnorm
#' @examples
#' m <- 160
#' s <- 10
#' K1 <- floor(m/(s * 4))
#' d <- 1
#' barmu <- 4
#' dd <- dyadic.from.window.size(m, s, method = 2)
#' leaf_list <- dd$leaf_list
#' muC <- gen.mu.leaves(m = m, K1 = K1, d = d, grouped = FALSE, 
#'                     setting = "const", barmu = barmu, leaf_list =leaf_list)
#' muC <- gen.mu.leaves(m = m, K1 = K1, d = d, grouped = TRUE, 
#'                     setting = "const", barmu = barmu, leaf_list =leaf_list)
#' muG <- gen.mu.leaves(m = m, K1 = K1, d = d, grouped = FALSE, 
#'                     setting = "gauss", barmu = barmu, leaf_list =leaf_list)
#' muP <- gen.mu.leaves(m = m, K1 = K1, d = d, grouped = FALSE, 
#'                     setting = "poisson", barmu = barmu, leaf_list =leaf_list)
#' mu <- cbind(constant = muC, Gaussian = muG, Poisson = muP)
#' matplot(mu, t = 's')
gen.mu.leaves <- function(m, K1, d, grouped, setting, barmu, leaf_list) {
    mu <- numeric(m)
    K <- length(leaf_list)
    if (K1 > K) 
        stop("K1>K,\nwe don't have so many leaves")
    active_leaves <- numeric(K1)
    if (grouped) {
        active_leaves <- seq(1, K1) # + sample(seq(0, K - K1), 1)
    } else {
        active_leaves <- sample(seq(1, K), K1)
    }
    for (i in active_leaves) {
        length_leaf <- length(leaf_list[[i]])
        m1loc <- floor(length_leaf * d)
        signal <- sample(length_leaf, m1loc)
        mu[leaf_list[[i]][signal]] <- switch(setting, const = {
            barmu
        }, rgauss = {
            rnorm(m1loc, mean = barmu, sd = sqrt(barmu))
        }, gauss = {
            gauss_bloc(barmu, length_leaf)[signal]
        }, poisson = {
            rpois(m1loc, 999 * barmu/1000) + barmu/1000
        })
    }
    return(mu)
}

#' Generate one-sided p-values associated to a given signal with equi-correlated noise
#' 
#' @param m An integer value, the number of hypotheses
#' @param mu A vector of \eqn{m} signal values
#' @param rho A numeric value in \eqn{[0,1]}, the level of equi-correlation between test statistics
#' @return A vector of \eqn{m} one-sided \eqn{p}-values
#' @export
#' @examples
#' m <- 100
#' s <- 10
#' K1 <- floor(m/(s * 4))
#' d <- 1
#' barmu <- 4
#' dd <- dyadic.from.window.size(m, s, method = 2)
#' leaf_list <- dd$leaf_list
#' mu <- gen.mu.leaves(m = m, K1 = K1, d = d, grouped = FALSE, 
#'                     setting = "const", barmu = barmu, leaf_list =leaf_list)
#' pvals <- gen.p.values(m = m, mu = mu, rho = 0)
#' plot(-log(pvals), t = 'b')
gen.p.values <- function(m, mu, rho) {
    stopifnot(m == length(mu)) ## sanity check
    Z <- rnorm(m + 1, 0, 1)
    Y <- sqrt(1 - rho) * Z[seq_len(m)] + sqrt(rho) * Z[m + 1]
    return(pnorm(Y + mu, lower.tail = FALSE))
}

#' Plot confidence envelopes for the number of false positives
#' 
#@export
#' @examples
#' m <- 16
#' s <- 2
#' K1 <- floor(m/(s * 4))
#' d <- 1
#' barmu <- 4
#' dd <- dyadic.from.window.size(m, s, method = 2)
#' leaf_list <- dd$leaf_list
#' mu <- gen.mu.leaves(m = m, K1 = K1, d = d, grouped = FALSE, 
#'                     setting = "const", barmu = barmu, leaf_list =leaf_list)
#' pvals <- gen.p.values(m = m, mu = mu, rho = 0)
#' alpha <- 0.1
#' ZL <- zetas.tree(dd$C, leaf_list, zeta.DKWM, pvals, alpha = alpha)
#' plotting(C = dd$C, ZL = ZL, leaf_list = leaf_list, method = "threshold", pvalues = pvals, mu = mu, alpha = alpha)
plotting <- function(C, ZL, leaf_list, method, pvalues, mu, alpha) {
    m <- length(pvalues)
    o <- order(pvalues)
    omu <- order(mu, decreasing = TRUE)
    vecVstar <- numeric(m)
    for (i in 1:m) {
        vecVstar[i] <- switch(method, threshold = {
            V.star(o[1:i], C, ZL, leaf_list)
        }, add = {
            V.star(omu[1:i], C, ZL, leaf_list)
        })
    }
    plot(1:m, vecVstar, type = "l")
    vequo <- numeric(m)
    for (i in 1:m) {
        vequo[i] <- switch(method, threshold = {
            min(sapply(1:i, function(k) min(sum(pvalues[o[1:i]] > alpha * k/m) + k - 1, i)))
        }, add = {
            min(sapply(1:i, function(k) min(sum(pvalues[omu[1:i]] > alpha * k/m) + k - 1, i)))
        })
    }
    lines(1:m, vequo, col = 2)
    cbind(tree = vecVstar, Simes = vequo)
}

#' @examples
#' m <- 1000
#' s <- 10
#' K1 <- floor(m/(s * 4))
#' d <- 1
#' barmu <- 4
#' dd <- dyadic.from.window.size(m, s, method = 2)
#' leaf_list <- dd$leaf_list
#' mu <- gen.mu.leaves(m = m, K1 = K1, d = d, grouped = FALSE, 
#'                     setting = "const", barmu = barmu, leaf_list =leaf_list)
#' pvals <- gen.p.values(m = m, mu = mu, rho = 0)
#' alpha <- 0.1
#' ZL <- zetas.tree(dd$C, leaf_list, zeta.DKWM, pvals, alpha = alpha)
#' system.time(plotting(C = dd$C, ZL = ZL, leaf_list = leaf_list, method = "threshold", pvalues = pvals, mu = mu, alpha = alpha))
#' 
#' treeFam <- list(tree = dd$C, leaves = leaf_list, zetas = ZL)
#' op <- order(pvals)
#' omu <- order(mu, decreasing = TRUE)
#' system.time(Vp <- curveVstar_tree(treeFam, op))
#' lines(Vp, col=3, lty=2)
#' Vmu <- curveVstar_tree(treeFam, omu)
#' 
#' # Simes
#' thrSimes <- SimesThresholdFamily(m)(alpha)
#' stats <- qnorm(1-pvals)
#' VpS <- curveMaxFP(stats[op], thrSimes)
#' VpS2 <- curveMaxFP(stats[op], thrSimes, flavor = "BNR2014")
#' system.time(VpS3 <- 1:m - sapply(1:m, FUN=function(kk) posthocBySimes(pvals, op[1:kk], alpha)))

#' lines(VpS, col=4, lty=2)

#' #VmuS <- curveMaxFP(stats[omu], thrSimes) # does not work as stats[omu] can be increasing
#' system.time(VmuS2 <- curveMaxFP(stats[omu], thrSimes, flavor = "BNR2014"))
#' system.time(VmuS3 <- 1:m - sapply(1:m, FUN=function(kk) posthocBySimes(pvals, omu[1:kk], alpha)))
curveVstar_tree <- function(treeFam, ordering) {
    C <- treeFam$tree
    leaf_list <- treeFam$leaves
    ZL <- treeFam$zetas
    
    m <- length(ordering)
    stopifnot(length(unlist(leaf_list)) == m) ## sanity check
    
    vecVstar <- numeric(m)
    for (ii in 1:m) {
        vecVstar[ii] <- V.star(ordering[1:ii], C, ZL, leaf_list)
    }
    vecVstar
}

